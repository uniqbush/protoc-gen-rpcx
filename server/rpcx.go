package server

import (
	"fmt"
	"github.com/rpcxio/protoc-gen-gogorpcx/utils"
	"io/ioutil"
	"os"
	"regexp"
	"strings"

	pb "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	"github.com/gogo/protobuf/protoc-gen-gogo/generator"
)

const (
	rpcxServerPkgPath   = "github.com/smallnest/rpcx/server"
	rpcxClientPkgPath   = "github.com/smallnest/rpcx/client"
	rpcxProtocolPkgPath = "github.com/smallnest/rpcx/protocol"
)

func init() {
	generator.RegisterPlugin(new(rpcx))
}

type rpcx struct {
	gen *generator.Generator
}

// Name returns the name of this plugin
func (p *rpcx) Name() string {
	return "rpcx"
}

// Init initializes the plugin.
func (p *rpcx) Init(gen *generator.Generator) {
	p.gen = gen
}

// Given a type name defined in a .proto, return its object.
// Also record that we're using it, to guarantee the associated import.
func (p *rpcx) objectNamed(name string) generator.Object {
	p.gen.RecordTypeUse(name)
	return p.gen.ObjectNamed(name)
}

// Given a type name defined in a .proto, return its name as we will print it.
func (p *rpcx) typeName(str string) string {
	return p.gen.TypeName(p.objectNamed(str))
}

// GenerateImports generates the import declaration for this file.
func (p *rpcx) GenerateImports(file *generator.FileDescriptor) {
}

// P forwards to g.gen.P.
func (p *rpcx) P(args ...interface{}) { p.gen.P(args...) }

// Generate generates code for the services in the given file.
func (p *rpcx) Generate(file *generator.FileDescriptor) {
	if len(file.FileDescriptorProto.Service) == 0 {
		return
	}

	// generate all services
	for i, service := range file.FileDescriptorProto.Service {
		p.gen.Reset()
		p.generateService(file, service, i)
		serviceName := strings.ToLower(service.GetName())

		basePath := fmt.Sprintf("../%s", serviceName)

		err := os.MkdirAll(basePath+"/cmd", 0644)
		if err != nil {
			panic(err)
		}

		err = os.MkdirAll(basePath+"/internel", 0644)
		if err != nil {
			panic(err)
		}

		isExist := utils.IsExist(basePath + "/cmd/main.go")
		if !isExist {
			generateMain(basePath+"/cmd/main.go", service)
		}

		utils.GenerateMod(fmt.Sprintf("../%s", serviceName), serviceName)

		b := append([]byte(fmt.Sprintf(`package internel

import (
	"github.com/smallnest/rpcx/server"
)
`)), p.gen.Bytes()...)
		err = ioutil.WriteFile(fmt.Sprintf("%s/internel/%sserver_autogen.go", basePath, serviceName), b, 0644)
		if err != nil {
			panic(err)
		}
	}
}

func generateMain(path string, service *pb.ServiceDescriptorProto) {
	originServiceName := service.GetName()
	serviceName := upperFirstLatter(originServiceName)
	content := fmt.Sprintf(`package main
import (

)

func main()  {
	internel.ServeFor%s("127.0.0.1:8080")
}
`, serviceName)
	err := ioutil.WriteFile(path, []byte(content), 0644)
	if err != nil {
		panic(err)
	}
}

// generateService generates all the code for the named service
func (p *rpcx) generateService(file *generator.FileDescriptor, service *pb.ServiceDescriptorProto, index int) {
	originServiceName := service.GetName()
	serviceName := upperFirstLatter(originServiceName)
	lowerServiceName := strings.ToLower(originServiceName)
	p.P("// This following code was generated by rpcx")
	p.P(fmt.Sprintf("// Gernerated from %s", file.GetName()))

	//p.P("package main")
	//	p.P()
	//	p.P(`import (
	//	"github.com/smallnest/rpcx/server"
	//	"context"
	//)`)

	// server
	p.P()
	p.P(fmt.Sprintf(`type %[1]sImpl struct {}

func ServeFor%[1]s(addr string) error{
	s := server.NewServer()
	s.RegisterName("%[1]s", new(%[1]sImpl), "")
	return s.Serve("tcp", addr)
}
	`, serviceName))
	p.P()

	fileMap := map[string]string{}

	for _, method := range service.Method {
		//bak := &rpcx{gen: &generator.Generator{}}
		code := p.generateServerCode(service, method)

		reg := regexp.MustCompile(`2000000:"([a-zA-Z]+)"`)
		params := reg.FindStringSubmatch(method.Options.String())

		var fileName string
		if len(params) == 0 {
			fileName = strings.ToLower(service.GetName())
		} else {
			fileName = params[1]
		}

		pathName := fmt.Sprintf("../%s/internel/%s.go", lowerServiceName, fileName)

		if content, ok := fileMap[fileName]; ok {
			if strings.Contains(content, upperFirstLatter(method.GetName())) {
				continue
			} else {
				utils.WriteFile(pathName, code)
			}
		} else {
			exist := utils.IsExist(pathName)
			if !exist {
				err := os.MkdirAll(fmt.Sprintf("../%s/internel", lowerServiceName), 0644)
				if err != nil {
					panic(err)
				}

				code = fmt.Sprintf(`package internel

import (
	"context"
	"%s"
)

%s
`, lowerServiceName, code)
				utils.WriteFile(pathName, code)
			} else {
				fileContent, err := os.ReadFile(pathName)
				if err != nil {
					panic(err)
				}

				fileMap[fileName] = string(fileContent)
				if strings.Contains(fileMap[fileName], upperFirstLatter(method.GetName())) {
					continue
				} else {
					utils.WriteFile(pathName, code)
				}
			}
		}
	}
}

func (p *rpcx) generateAbleCode(method *pb.MethodDescriptorProto) {
	methodName := upperFirstLatter(method.GetName())
	inType := p.typeName(method.GetInputType())
	outType := p.typeName(method.GetOutputType())
	p.P(fmt.Sprintf(`// %[1]s is server rpc method as defined
		%[1]s(ctx context.Context, args *%[2]s, reply *%[3]s) (err error)
	`, methodName, inType, outType))
}

func (p *rpcx) generateServerCode(service *pb.ServiceDescriptorProto, method *pb.MethodDescriptorProto) string {
	methodName := upperFirstLatter(method.GetName())
	serviceName := upperFirstLatter(service.GetName())
	pkgName := strings.ToLower(service.GetName())
	inType := p.typeName(method.GetInputType())
	outType := p.typeName(method.GetOutputType())
	return fmt.Sprintf(`func (s *%sImpl) %s(ctx context.Context, req *%s.%s, rsp *%s.%s) (err error){
	// TODO: add business logics

	return nil
}

`, serviceName, methodName, pkgName, inType, pkgName, outType)
}

func (p *rpcx) generateClientCode(service *pb.ServiceDescriptorProto, method *pb.MethodDescriptorProto) {
	methodName := upperFirstLatter(method.GetName())
	serviceName := upperFirstLatter(service.GetName())
	inType := p.typeName(method.GetInputType())
	outType := p.typeName(method.GetOutputType())
	p.P(fmt.Sprintf(`func (c *%sClient) %s(ctx context.Context, args *%s)(reply *%s, err error){
	reply = &%s{}
	err = c.xclient.Call(ctx,"%s",args, reply)
	return reply, err
}`, serviceName, methodName, inType, outType, outType, method.GetName()))
}

func (p *rpcx) generateOneClientCode(service *pb.ServiceDescriptorProto, method *pb.MethodDescriptorProto) {
	methodName := upperFirstLatter(method.GetName())
	serviceName := upperFirstLatter(service.GetName())
	inType := p.typeName(method.GetInputType())
	outType := p.typeName(method.GetOutputType())
	p.P(fmt.Sprintf(`func (c *%sOneClient) %s(ctx context.Context, args *%s)(reply *%s, err error){
	reply = &%s{}
	err = c.oneclient.Call(ctx,c.serviceName,"%s",args, reply)
	return reply, err
}`, serviceName, methodName, inType, outType, outType, method.GetName()))
}

// upperFirstLatter make the fisrt charater of given string  upper class
func upperFirstLatter(s string) string {
	if len(s) == 0 {
		return ""
	}
	if len(s) == 1 {
		return strings.ToUpper(string(s[0]))
	}
	return strings.ToUpper(string(s[0])) + s[1:]
}
